# automatically generated by the FlatBuffers compiler, do not modify

# namespace: LOCO

import flatbuffers
from flatbuffers.compat import import_numpy

np = import_numpy()


class TopLoco(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAsTopLoco(cls, buf, offset):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TopLoco()
        x.Init(buf, n + offset)
        return x

    # TopLoco
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # TopLoco
    def Constants(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(
                flatbuffers.number_types.Uint8Flags,
                a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1),
            )
        return 0

    # TopLoco
    def ConstantsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # TopLoco
    def ConstantsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TopLoco
    def ConstantsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # TopLoco
    def Categories(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from LOCO.Category import Category

            obj = Category()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # TopLoco
    def CategoriesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TopLoco
    def CategoriesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # TopLoco
    def Trackmap(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(
                flatbuffers.number_types.Int32Flags,
                a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4),
            )
        return 0

    # TopLoco
    def TrackmapAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # TopLoco
    def TrackmapLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TopLoco
    def TrackmapIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # TopLoco
    def LinkedTracks(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from LOCO.Track import Track

            obj = Track()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # TopLoco
    def LinkedTracksLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TopLoco
    def LinkedTracksIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # TopLoco
    def Images(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from LOCO.Image import Image

            obj = Image()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # TopLoco
    def ImagesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TopLoco
    def ImagesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # TopLoco
    def Annotations(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from LOCO.Annotation import Annotation

            obj = Annotation()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # TopLoco
    def AnnotationsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TopLoco
    def AnnotationsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # TopLoco
    def States(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from LOCO.State import State

            obj = State()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # TopLoco
    def StatesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TopLoco
    def StatesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # TopLoco
    def SensorParams(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from LOCO.SensorParameters import SensorParameters

            obj = SensorParameters()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None


def TopLocoStart(builder):
    builder.StartObject(8)


def TopLocoAddConstants(builder, constants):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(constants), 0
    )


def TopLocoStartConstantsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)


def TopLocoAddCategories(builder, categories):
    builder.PrependUOffsetTRelativeSlot(
        1, flatbuffers.number_types.UOffsetTFlags.py_type(categories), 0
    )


def TopLocoStartCategoriesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)


def TopLocoAddTrackmap(builder, trackmap):
    builder.PrependUOffsetTRelativeSlot(
        2, flatbuffers.number_types.UOffsetTFlags.py_type(trackmap), 0
    )


def TopLocoStartTrackmapVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)


def TopLocoAddLinkedTracks(builder, linkedTracks):
    builder.PrependUOffsetTRelativeSlot(
        3, flatbuffers.number_types.UOffsetTFlags.py_type(linkedTracks), 0
    )


def TopLocoStartLinkedTracksVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)


def TopLocoAddImages(builder, images):
    builder.PrependUOffsetTRelativeSlot(
        4, flatbuffers.number_types.UOffsetTFlags.py_type(images), 0
    )


def TopLocoStartImagesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)


def TopLocoAddAnnotations(builder, annotations):
    builder.PrependUOffsetTRelativeSlot(
        5, flatbuffers.number_types.UOffsetTFlags.py_type(annotations), 0
    )


def TopLocoStartAnnotationsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)


def TopLocoAddStates(builder, states):
    builder.PrependUOffsetTRelativeSlot(
        6, flatbuffers.number_types.UOffsetTFlags.py_type(states), 0
    )


def TopLocoStartStatesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)


def TopLocoAddSensorParams(builder, sensorParams):
    builder.PrependUOffsetTRelativeSlot(
        7, flatbuffers.number_types.UOffsetTFlags.py_type(sensorParams), 0
    )


def TopLocoEnd(builder):
    return builder.EndObject()


import LOCO.Annotation
import LOCO.Category
import LOCO.Image
import LOCO.SensorParameters
import LOCO.State
import LOCO.Track

try:
    from typing import List, Optional
except:
    pass


class TopLocoT(object):
    # TopLocoT
    def __init__(self):
        self.constants = None  # type: List[int]
        self.categories = None  # type: List[LOCO.Category.CategoryT]
        self.trackmap = None  # type: List[int]
        self.linkedTracks = None  # type: List[LOCO.Track.TrackT]
        self.images = None  # type: List[LOCO.Image.ImageT]
        self.annotations = None  # type: List[LOCO.Annotation.AnnotationT]
        self.states = None  # type: List[LOCO.State.StateT]
        self.sensorParams = (
            None
        )  # type: Optional[LOCO.SensorParameters.SensorParametersT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        topLoco = TopLoco()
        topLoco.Init(buf, pos)
        return cls.InitFromObj(topLoco)

    @classmethod
    def InitFromObj(cls, topLoco):
        x = TopLocoT()
        x._UnPack(topLoco)
        return x

    # TopLocoT
    def _UnPack(self, topLoco):
        if topLoco is None:
            return
        if not topLoco.ConstantsIsNone():
            if np is None:
                self.constants = []
                for i in range(topLoco.ConstantsLength()):
                    self.constants.append(topLoco.Constants(i))
            else:
                self.constants = topLoco.ConstantsAsNumpy()
        if not topLoco.CategoriesIsNone():
            self.categories = []
            for i in range(topLoco.CategoriesLength()):
                if topLoco.Categories(i) is None:
                    self.categories.append(None)
                else:
                    category_ = LOCO.Category.CategoryT.InitFromObj(
                        topLoco.Categories(i)
                    )
                    self.categories.append(category_)
        if not topLoco.TrackmapIsNone():
            if np is None:
                self.trackmap = []
                for i in range(topLoco.TrackmapLength()):
                    self.trackmap.append(topLoco.Trackmap(i))
            else:
                self.trackmap = topLoco.TrackmapAsNumpy()
        if not topLoco.LinkedTracksIsNone():
            self.linkedTracks = []
            for i in range(topLoco.LinkedTracksLength()):
                if topLoco.LinkedTracks(i) is None:
                    self.linkedTracks.append(None)
                else:
                    track_ = LOCO.Track.TrackT.InitFromObj(topLoco.LinkedTracks(i))
                    self.linkedTracks.append(track_)
        if not topLoco.ImagesIsNone():
            self.images = []
            for i in range(topLoco.ImagesLength()):
                if topLoco.Images(i) is None:
                    self.images.append(None)
                else:
                    image_ = LOCO.Image.ImageT.InitFromObj(topLoco.Images(i))
                    self.images.append(image_)
        if not topLoco.AnnotationsIsNone():
            self.annotations = []
            for i in range(topLoco.AnnotationsLength()):
                if topLoco.Annotations(i) is None:
                    self.annotations.append(None)
                else:
                    annotation_ = LOCO.Annotation.AnnotationT.InitFromObj(
                        topLoco.Annotations(i)
                    )
                    self.annotations.append(annotation_)
        if not topLoco.StatesIsNone():
            self.states = []
            for i in range(topLoco.StatesLength()):
                if topLoco.States(i) is None:
                    self.states.append(None)
                else:
                    state_ = LOCO.State.StateT.InitFromObj(topLoco.States(i))
                    self.states.append(state_)
        if topLoco.SensorParams() is not None:
            self.sensorParams = LOCO.SensorParameters.SensorParametersT.InitFromObj(
                topLoco.SensorParams()
            )

    # TopLocoT
    def Pack(self, builder):
        if self.constants is not None:
            if np is not None and type(self.constants) is np.ndarray:
                constants = builder.CreateNumpyVector(self.constants)
            else:
                TopLocoStartConstantsVector(builder, len(self.constants))
                for i in reversed(range(len(self.constants))):
                    builder.PrependUint8(self.constants[i])
                constants = builder.EndVector(len(self.constants))
        if self.categories is not None:
            categorieslist = []
            for i in range(len(self.categories)):
                categorieslist.append(self.categories[i].Pack(builder))
            TopLocoStartCategoriesVector(builder, len(self.categories))
            for i in reversed(range(len(self.categories))):
                builder.PrependUOffsetTRelative(categorieslist[i])
            categories = builder.EndVector(len(self.categories))
        if self.trackmap is not None:
            if np is not None and type(self.trackmap) is np.ndarray:
                trackmap = builder.CreateNumpyVector(self.trackmap)
            else:
                TopLocoStartTrackmapVector(builder, len(self.trackmap))
                for i in reversed(range(len(self.trackmap))):
                    builder.PrependInt32(self.trackmap[i])
                trackmap = builder.EndVector(len(self.trackmap))
        if self.linkedTracks is not None:
            linkedTrackslist = []
            for i in range(len(self.linkedTracks)):
                linkedTrackslist.append(self.linkedTracks[i].Pack(builder))
            TopLocoStartLinkedTracksVector(builder, len(self.linkedTracks))
            for i in reversed(range(len(self.linkedTracks))):
                builder.PrependUOffsetTRelative(linkedTrackslist[i])
            linkedTracks = builder.EndVector(len(self.linkedTracks))
        if self.images is not None:
            imageslist = []
            for i in range(len(self.images)):
                imageslist.append(self.images[i].Pack(builder))
            TopLocoStartImagesVector(builder, len(self.images))
            for i in reversed(range(len(self.images))):
                builder.PrependUOffsetTRelative(imageslist[i])
            images = builder.EndVector(len(self.images))
        if self.annotations is not None:
            annotationslist = []
            for i in range(len(self.annotations)):
                annotationslist.append(self.annotations[i].Pack(builder))
            TopLocoStartAnnotationsVector(builder, len(self.annotations))
            for i in reversed(range(len(self.annotations))):
                builder.PrependUOffsetTRelative(annotationslist[i])
            annotations = builder.EndVector(len(self.annotations))
        if self.states is not None:
            stateslist = []
            for i in range(len(self.states)):
                stateslist.append(self.states[i].Pack(builder))
            TopLocoStartStatesVector(builder, len(self.states))
            for i in reversed(range(len(self.states))):
                builder.PrependUOffsetTRelative(stateslist[i])
            states = builder.EndVector(len(self.states))
        if self.sensorParams is not None:
            sensorParams = self.sensorParams.Pack(builder)
        TopLocoStart(builder)
        if self.constants is not None:
            TopLocoAddConstants(builder, constants)
        if self.categories is not None:
            TopLocoAddCategories(builder, categories)
        if self.trackmap is not None:
            TopLocoAddTrackmap(builder, trackmap)
        if self.linkedTracks is not None:
            TopLocoAddLinkedTracks(builder, linkedTracks)
        if self.images is not None:
            TopLocoAddImages(builder, images)
        if self.annotations is not None:
            TopLocoAddAnnotations(builder, annotations)
        if self.states is not None:
            TopLocoAddStates(builder, states)
        if self.sensorParams is not None:
            TopLocoAddSensorParams(builder, sensorParams)
        topLoco = TopLocoEnd(builder)
        return topLoco
